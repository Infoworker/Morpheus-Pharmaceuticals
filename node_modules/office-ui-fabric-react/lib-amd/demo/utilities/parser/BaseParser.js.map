{"version":3,"sources":["demo/utilities/parser/BaseParser.ts"],"names":[],"mappings":"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","file":"demo/utilities/parser/BaseParser.js","sourcesContent":["\n/**\n * Base for a parser - does not actually do any parsing.\n */\nexport class BaseParser {\n  private _currLocation = 0;\n  private _str: string;\n  private _strLength: number;\n\n  public constructor(_str: string) {\n    this._str = _str;\n    this._strLength = _str.length;\n  }\n\n  protected eat(match: string): string {\n    if (this._str.charAt(this._currLocation) === match) {\n      return this._str.charAt(this._currLocation++);\n    }\n\n    return undefined;\n  }\n\n  protected eatSpacesAndNewlines(): string {\n    return this.eatWhileRegex(/[ \\r\\n]/);\n  }\n\n  protected eatWhile(match: string): string {\n    let i = 0;\n\n    while (this._str.charAt(this._currLocation + i) === match) {\n      i++;\n      if (i + this._currLocation > this._strLength) {\n        break;\n      }\n    }\n\n    this._currLocation += i;\n    return this._str.substr(this._currLocation - i, i);\n  }\n\n  protected eatWhileRegex(match: RegExp): string {\n    let i = 0;\n\n    while (match.test(this._str.charAt(this._currLocation + i))) {\n      i++;\n      if (i + this._currLocation > this._strLength) {\n        break;\n      }\n    }\n\n    this._currLocation += i;\n    return this._str.substr(this._currLocation - i, i);\n  }\n\n  protected eatWord(word: string): string {\n    let len = word.length;\n\n    if (this.peekAhead(len) === word) {\n      this._currLocation += len;\n      return word;\n    }\n\n    return undefined;\n  }\n\n  protected eatUntil(match: RegExp): string {\n    let i = 0;\n\n    while (!match.test(this._str.charAt(this._currLocation + i))) {\n      i++;\n      if (i + this._currLocation > this._strLength) {\n        break;\n      }\n    }\n\n    this._currLocation += i;\n    return this._str.substr(this._currLocation - i, i);\n  }\n\n  protected peek(): string {\n    return this._str.charAt(this._currLocation);\n  }\n\n  protected peekAhead(by: number): string {\n    return this._str.substr(this._currLocation, by);\n  }\n\n  protected hasNext(): boolean {\n    return this._currLocation < this._strLength - 1;\n  }\n\n  /**\n   * Advances the stream if possible.\n   *\n   * @protected\n   * @returns {string} The token that was advanced over, or undefined if it wasn't possible to advance.\n   */\n  protected next(): string {\n    if (this.hasNext()) {\n      return this._str.charAt(this._currLocation++);\n    }\n\n    return undefined;\n  }\n\n  protected reset(): void {\n    this._currLocation = 0;\n  }\n}\n"],"sourceRoot":"../../../../src"}