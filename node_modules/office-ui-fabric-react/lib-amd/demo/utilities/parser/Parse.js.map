{"version":3,"sources":["demo/utilities/parser/Parse.ts"],"names":[],"mappings":";;IAIA;;;;;;;;;;;;;;OAcG;IACH,eAAsB,MAAc,EAAE,wBAAiC;QACrE,IAAI,KAAK,GAAgB,EAAE,CAAC;QAC5B,IAAI,KAAK,GAAW,IAAI,CAAC;QACzB,IAAI,SAAS,CAAC;QAEd,IAAI,kBAAkB,GAAG,UAAC,IAAY,IAAK,OAAA,IAAI,KAAK,WAAW,GAAG,YAAY,GAAG,OAAO,EAA7C,CAA6C,CAAC;QACzF,IAAI,YAAY,GAAG,UAAC,IAAY,IAAK,OAAA,IAAI,KAAK,WAAW,GAAG,oBAAY,CAAC,SAAS,GAAG,oBAAY,CAAC,IAAI,EAAjE,CAAiE,CAAC;QAEvG,EAAE,CAAC,CAAC,wBAAwB,CAAC,CAAC,CAAC;YAC7B,KAAK,GAAG,IAAI,MAAM,CAAC,6BAA2B,wBAAwB,4CAAyC,CAAC,CAAC;YACjH,IAAI,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACrC,EAAE,CAAC,CAAC,WAAW,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;gBAC1C,SAAS,GAAG,qBAAqB,CAAC,WAAW,CAAC,CAAC;gBAC/C,MAAM,CAAC,CAAY;wBACjB,IAAI,EAAE,wBAAwB;wBAC9B,YAAY,EAAE,wBAAwB,GAAG,kBAAkB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;wBAC3E,YAAY,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;wBAC1C,QAAQ,EAAE,SAAS;qBACpB,CAAC,CAAC;YACL,CAAC;QACH,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,KAAK,GAAG,IAAI,MAAM,CAAC,wEAAwE,EAAE,GAAG,CAAC,CAAC;YAClG,IAAI,WAAW,SAAiB,CAAC;YACjC,IAAI,OAAO,GAAqB,EAAE,CAAC;YACnC,OAAO,CAAC,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;gBACnD,SAAS,GAAG,qBAAqB,CAAC,WAAW,CAAC,CAAC;gBAC/C,OAAO,CAAC,IAAI,CAAY;oBACtB,IAAI,EAAE,WAAW,CAAC,CAAC,CAAC;oBACpB,YAAY,EAAE,WAAW,CAAC,CAAC,CAAC,GAAG,kBAAkB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;oBACjE,YAAY,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;oBAC1C,QAAQ,EAAE,SAAS;iBACpB,CAAC,CAAC;YACL,CAAC;YAED,MAAM,CAAC,OAAO,CAAC;QACjB,CAAC;QAED,MAAM,CAAC,KAAK,CAAC;IACf,CAAC;IAtCe,aAAK,QAsCpB,CAAA;IAED,+BAA+B,WAA4B;QACzD,IAAI,SAAS,CAAC;QACd,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,KAAK,WAAW,CAAC,CAAC,CAAC;YACnC,IAAI,MAAM,GAAG,IAAI,6CAAqB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;YACvD,SAAS,GAAG,MAAM,CAAC,KAAK,EAAE,CAAC;YAC3B,MAAM,GAAG,IAAI,CAAC;QAChB,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,IAAI,MAAM,GAAG,IAAI,mCAAgB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;YAClD,SAAS,GAAG,MAAM,CAAC,KAAK,EAAE,CAAC;YAC3B,MAAM,GAAG,IAAI,CAAC;QAChB,CAAC;QACD,MAAM,CAAC,SAAS,CAAC;IACnB,CAAC","file":"demo/utilities/parser/Parse.js","sourcesContent":["import { IProperty, PropertyType } from '../../components/index';\nimport { InterfaceParserHelper } from './InterfaceParserHelper';\nimport { EnumParserHelper } from './EnumParserHelper';\n\n/**\n * Given some valid, well linted Typescript source code, extracts exported interfaces and enums.\n *\n * Note: requires that the closing '}' of interfaces and enums is the first char on its own line.\n *       It should otherwise be reasonably robust to handle various commenting or even code layout\n *       styles within the interface or enum.\n *\n * To specify default values for interfaces, use the JSDoc @default or @defaultvalue markup.\n * The rest of the line after @default will be captured as the default value.\n *\n * @export\n * @param {string} source Valid, reasonably well linted Typescript source code.\n * @param {string} [propsInterfaceOrEnumName] Name of an interface or enum if you only want to parse said interface or enum.\n * @returns {Array<IProperty>} An array of properties.\n */\nexport function parse(source: string, propsInterfaceOrEnumName?: string): IProperty[] {\n  let props: IProperty[] = [];\n  let regex: RegExp = null;\n  let parseInfo;\n\n  let propertyNameSuffix = (type: string) => type === 'interface' ? ' interface' : ' enum';\n  let propertyType = (type: string) => type === 'interface' ? PropertyType.interface : PropertyType.enum;\n\n  if (propsInterfaceOrEnumName) {\n    regex = new RegExp(`export (interface|enum) ${propsInterfaceOrEnumName}(?: extends .*?)? \\\\{(.*[\\\\r\\\\n]*)*?\\\\}`);\n    let regexResult = regex.exec(source);\n    if (regexResult && regexResult.length > 0) {\n      parseInfo = _parseEnumOrInterface(regexResult);\n      return [<IProperty>{\n        name: propsInterfaceOrEnumName,\n        propertyName: propsInterfaceOrEnumName + propertyNameSuffix(regexResult[1]),\n        propertyType: propertyType(regexResult[1]),\n        property: parseInfo\n      }];\n    }\n  } else {\n    regex = new RegExp(`export (interface|enum) (\\\\S*?)(?: extends .*?)? \\\\{(.*[\\\\r\\\\n]*)*?\\\\}`, 'g');\n    let regexResult: RegExpExecArray;\n    let results: Array<IProperty> = [];\n    while ((regexResult = regex.exec(source)) !== null) {\n      parseInfo = _parseEnumOrInterface(regexResult);\n      results.push(<IProperty>{\n        name: regexResult[2],\n        propertyName: regexResult[2] + propertyNameSuffix(regexResult[1]),\n        propertyType: propertyType(regexResult[1]),\n        property: parseInfo\n      });\n    }\n\n    return results;\n  }\n\n  return props;\n}\n\nfunction _parseEnumOrInterface(regexResult: RegExpExecArray) {\n  let parseInfo;\n  if (regexResult[1] === 'interface') {\n    let parser = new InterfaceParserHelper(regexResult[0]);\n    parseInfo = parser.parse();\n    parser = null;\n  } else {\n    let parser = new EnumParserHelper(regexResult[0]);\n    parseInfo = parser.parse();\n    parser = null;\n  }\n  return parseInfo;\n}\n"],"sourceRoot":"../../../../src"}