{"version":3,"sources":["utilities/focus.ts"],"names":[],"mappings":"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","file":"utilities/focus.js","sourcesContent":["/* tslint:disable:no-string-literal */\n\nimport { elementContains, getDocument } from './dom';\n\nconst IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';\nconst IS_VISIBLE_ATTRIBUTE = 'data-is-visible';\nconst FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\n\nexport function getFirstFocusable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean): HTMLElement {\n\n  return getNextElement(rootElement, currentElement, true, false, false, includeElementsInFocusZones);\n}\n\nexport function getLastFocusable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean): HTMLElement {\n\n  return getPreviousElement(rootElement, currentElement, true, false, true, includeElementsInFocusZones);\n}\n\n/**\n * Attempts to focus the first focusable element that is a child or child's child of the rootElement.\n * @return True if focus was set, false if it was not.\n * @param {HTMLElement} rootElement - element to start the search for a focusable child.\n */\nexport function focusFirstChild(\n  rootElement: HTMLElement): boolean {\n  let element: HTMLElement = getNextElement(rootElement, rootElement, true, false, false, true);\n\n  if (element) {\n    element.focus();\n    return true;\n  }\n  return false;\n}\n\n/** Traverse to find the previous element. */\nexport function getPreviousElement(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  checkNode?: boolean,\n  suppressParentTraversal?: boolean,\n  traverseChildren?: boolean,\n  includeElementsInFocusZones?: boolean): HTMLElement {\n\n  if (!currentElement ||\n    currentElement === rootElement) {\n    return null;\n  }\n\n  let isCurrentElementVisible = isElementVisible(currentElement);\n\n  // Check its children.\n  if (traverseChildren && (includeElementsInFocusZones || !isElementFocusZone(currentElement)) && isCurrentElementVisible) {\n    const childMatch = getPreviousElement(rootElement, currentElement.lastElementChild as HTMLElement, true, true, true, includeElementsInFocusZones);\n\n    if (childMatch) {\n      return childMatch;\n    }\n  }\n\n  // Check the current node, if it's not the first traversal.\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement)) {\n    return currentElement;\n  }\n\n  // Check its previous sibling.\n  const siblingMatch = getPreviousElement(rootElement, currentElement.previousElementSibling as HTMLElement, true, true, true, includeElementsInFocusZones);\n\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n\n  // Check its parent.\n  if (!suppressParentTraversal) {\n    return getPreviousElement(rootElement, currentElement.parentElement, true, false, false, includeElementsInFocusZones);\n  }\n\n  return null;\n}\n\n/** Traverse to find the next focusable element. */\nexport function getNextElement(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  checkNode?: boolean,\n  suppressParentTraversal?: boolean,\n  suppressChildTraversal?: boolean,\n  includeElementsInFocusZones?: boolean): HTMLElement {\n\n  if (\n    !currentElement ||\n    (currentElement === rootElement && suppressChildTraversal)) {\n    return null;\n  }\n\n  let isCurrentElementVisible = isElementVisible(currentElement);\n\n  // Check the current node, if it's not the first traversal.\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement)) {\n    return currentElement;\n  }\n\n  // Check its children.\n  if (!suppressChildTraversal && isCurrentElementVisible && (includeElementsInFocusZones || !isElementFocusZone(currentElement))) {\n    const childMatch = getNextElement(rootElement, currentElement.firstElementChild as HTMLElement, true, true, false, includeElementsInFocusZones);\n\n    if (childMatch) {\n      return childMatch;\n    }\n  }\n\n  if (currentElement === rootElement) {\n    return null;\n  }\n\n  // Check its sibling.\n  const siblingMatch = getNextElement(rootElement, currentElement.nextElementSibling as HTMLElement, true, true, false, includeElementsInFocusZones);\n\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n\n  if (!suppressParentTraversal) {\n    return getNextElement(rootElement, currentElement.parentElement, false, false, true, includeElementsInFocusZones);\n  }\n\n  return null;\n}\n\nexport function isElementVisible(element: HTMLElement): boolean {\n  // If the element is not valid, return false.\n  if (!element || !element.getAttribute) {\n    return false;\n  }\n\n  const visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE);\n\n  // If the element is explicitly marked with the visibility attribute, return that value as boolean.\n  if (visibilityAttribute !== null && visibilityAttribute !== undefined) {\n    return visibilityAttribute === 'true';\n  }\n\n  // Fallback to other methods of determining actual visibility.\n  return (element.offsetHeight !== 0 ||\n    element.offsetParent !== null ||\n    (element as any).isVisible === true); // used as a workaround for testing.\n}\n\nexport function isElementTabbable(element: HTMLElement): boolean {\n  return (\n    !!element &&\n    (element.tagName === 'A' ||\n      (element.tagName === 'BUTTON' && !(element as HTMLButtonElement).disabled) ||\n      (element.tagName === 'INPUT' && !(element as HTMLInputElement).disabled) ||\n      (element.tagName === 'TEXTAREA' && !(element as HTMLTextAreaElement).disabled) ||\n      (element.getAttribute && element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true')));\n}\n\nexport function isElementFocusZone(element?: HTMLElement): boolean {\n  return element && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE);\n}\n\nexport function doesElementContainFocus(element: HTMLElement) {\n  let currentActiveElement: HTMLElement = getDocument(element).activeElement as HTMLElement;\n  if (currentActiveElement && elementContains(element, currentActiveElement)) {\n    return true;\n  }\n  return false;\n}\n"],"sourceRoot":"../../src"}